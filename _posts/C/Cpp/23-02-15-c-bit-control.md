---
title:  "[C] 비트 조작"
excerpt: " "

categories:
  - C

toc: true
toc_sticky: true
 
date: 2023-02-15
---

# 2진수, 비트, 바이트

컴퓨터는 2진수를 사용한다는 것은 모두가 아는 사실이다. 13을 컴퓨터에 입력하면 컴퓨터는 1101(8 + 4 + 1)으로 변환한다.

## 2진 정수 

일반적으로 1 바이트는 9비트를 가진다. 그러나 C에서는 시스템이 사용하는 문자 집합을 저장하는 데 필요한 크기를 바이트(byte)라고 부른다. 그러므로 C에서는 1바이트가 8비트, 9비트, 16비트 또는 그 밖의 어떤 비트 수를 가질 수 있다. 그러나 메모리 칩과 데이터 전송률을 표시하는 데에는 8비트 바이트를 가정한다. 비트 해석은 왼쪽(최하위 비트)부터 오른쪽(최상위 비트)으로 읽어간다. 


![image](/assets/images/c_image_04.png)

## 부호 있는 정수

부호 있는 수들의 표현은 하드웨어에 의해 결정된다. 부호 있는 수들을 표현한느 가장 간단한 방법은 최상위 1비트를 부호 표현을 위한 것으로 사용하는 것이다. 이와 같은 '부호-크기' 표현에서, 10000001은 -1이고 00000001은 1이다. 따라서, 전체 범위는 -127 ~ +127이다.

이런 접근의 한 가지 단점은, 두 개의 0이 생기는 것과, 하나의 값을 나타내는 데 두 개의 비트 패턴을 써버리는 것이다.

따라서 2의 보수(2's complement) 방법이 이 문제를 해결한다. 이것이 오늘날 가장 보편적으로 사용되는 체계다. 이 방법은 0부터 127까지의 값들을, 0으로 설정된 최상위 비트를 뺀 나머지 7비트로 표현한다. 최상위 비트가 1이면 그 값은 음수가 된다. '부호-크기'표현과의 차이점은 그 음수의 값을 결정하는 데에서 나타난다. 9비트 패턴 100000000(256)에서 그 음수의 비트 패턴을 뺀 결과가 음수 값의 크기이다. 9비트 패턴 100000000 으로부터 음수용 비트 패턴을 빼면 결과는 값의 크기이다. 

```
100000000 - 10000000
```

위 값은 10000000이 되고 심진수로 표현하면 -128이다. 마찬가지로, 10000001은 -127이고, 11111111은 -1이다. 따라서 2의 보수는 -128부터 +127까지의 범위에 있는 수들을 나타낸다.

2의 보수 방법으로 표현된 2진수의 부호를 뒤집는 가장 간단한 방법은, 각 비트를 반전시키고 거기에 1을 더하는 것이다. 1은 00000001이기 때문에, -1은 11111110 + 1 즉 11111111이 된다.

1의 보수 방법은, 비트 패턴에 있는 각 비트를 반전시켜서 음수를 만든다. 예를 들어, 00000001은 1이고, 11111110은 -1이다. 1바이트 값의 범위는 -127부터 +127이다. 

# 2진 부동소수점 수

## 2진 소수

일반적으로 10진 소수(0.525)는 증가되는 10의 거듭제곱을 분모로 사용하여 다음과 같이 나타낼 수 있다.

```
5/10 + 2/100 + 5/1000
```

2진 소수에서는 증가되는 2의 거듭제곱을 분모로 사용한다. 그래서, 2진 소수(.101)는 다음과 같이 나타낼 수 있다.

```
1/2 + 0/4 + 1/8
```

이것의 10진 표기는

```
0.5 + 0 + 0.125
```

로 0.625이다.

1 / 2의 거듭제곱의 배수(3/4, 7/8 등)들을 제외한 소수들은 2진 표기로 정확히 표기할 수 없다. 

## 부동소수점 수의 표현

컴퓨터는 하나의 부동소수점 수를 표현하기 위해, (시스템마다 다른) 특정 개수의 비트들을 2진 소수를 저장하는 데 사용한다. 그리고 추가적인 비트들에 지수를 저장한다. 다시 말해서, 부동소수점 수의 실제 값은 2진 소수와 2진 지수의 곱으로 이루어진다. 예를 들어, 어떤 부동소수점 수에 4를 곱하면, 2진 지수는 2만큼 증가하고 2진 소수는 변하지 않는다. 2의 거듭제곱이 아닌 수를 곱하면, 2진 소수와 2진 지수가 모두 변한다.

# 8진수

8진수 체계는 8을 기수로, 0부터 7까지를 사용한다. 8진수 451은 다음과 같다.

```
4 x 64 + 5 x 8 + 1 x 1 = 297(10진수)
```

8진수의 각 숫자는 2진수의 세 숫자에 대응한다.

8진수|2진수
:---:|:---:
0|000
1|001
2|010
3|011
4|100
5|101
6|110
7|111

# 16진수

16을 기수로 사용하는데, 0에서 9까지는 숫자로, 10에서 15까지는 알파벳 A ~ F까지 표현한다. 예를 들어 16진수 A3F는 다음과 같다.

```
10 x 256 + 3 x 16 + 16 x 1 = 2623
```

16진수의 각 숫자는 2진수의 네 숫자에 대응한다. 그래서, 16진수 숫자 2개는 정확히 8비트 바이트에 대응한다. 첫 번째 숫자는 상위 4비트를, 두 번째 숫자는 하위 4비트를 나타낸다.

10진수|16진수|2진수|10진수|16진수|2진수
:---:|:---:|:---:|:---:|:---:|:---:
0|0|0000|8|8|1000
1|1|0001|9|9|1001
2|2|0010|10|A|1010
3|3|0011|11|B|1011
4|4|0100|12|C|1100
5|5|0101|13|D|1101
6|6|0110|14|E|1110
7|7|0111|15|F|1111

# C의 비트 단위 연산자
네 개의 비트 단위 논리 연산자가 (`char`형 포함) 정수형 데이터에 적용된다. 이들은 각 비트에 연산이 적용될 때 왼쪽이나 오른쪽에 있는 비트들에 영향을 받지 않는다.

## 1의 보수 또는 비트 단위 부정 연산자

단항 연산자 `~`은 각 비트에 대해 1은 0, 0은 1로 바꾼다.

```c
~(10011010) == (01100101)
```

`unsigned char` 형 `val`에 값 2가 대입되어 있다면, 이는 2진수 표기로 00000010이다. 따라서 `~val`은 값 11111101(253)이다. 이 연산자는 `val`의 값을 변경시키지 않는다는 것에 유의한다. 

## 비트 단위 논리곱(AND)

이항 연산자 `&`는 두 피연산자를 대응하는 비트끼리 서로 비교하여 새로운 값을 만든다. 두 비트가 모두 1일 때 결과 1비트가 1이 된다. 

```c
(110010011) & (00111101) == (00010001)
```

C는 비트 단위 논리곱-대입 결합 연산자 `&=`를 제공한다. 

```c
val &= 0377;
//다음과 같다
val = val & 0377;
```

## 비트 단위 논리합(OR)

이항 연산자 `|`는 두 피연산자를 대응하는 비트끼리 비교하여 두 비트 중 어느 하나라도 1이면 결과 비트가 1이된다.

```c
(10010011) | (00111101) == (10111111)
```

마찬가지로 비트 단위 논리합-대입 연산자를 제공한다.

```c
val |= 0377;
```

## 비트 단위 배타적 논리합(XOR)

이항 연산자 `^`는 두 피연산자를 대응하는 비트끼리 비교하여 서로 다른 값을 가지면 결과 비트가 1이 된다.

```c
(10010011) ^ (00111101) == (10101110)
```

```c
val ^= 0377;
```

## 용도

### 마스크

AND 연산자는 흔히 마스크와 함께 사용된다. on(1)과 off(0)로 설정된 비트 패턴을 마스크라고 한다. 

```c
#define MASK 2  //00000010

flags &= MASK;
```

위 내용은 1번 비트를 제외한 `flags`의 모든 비트를 0으로 설정한다. 마스크 값에 있는 0인 비트들이 `flags`의 비트들을 가리기(mask) 때문에 마스크라고 한다.

C에서 마스크의 가장 일반적 용도는 다음과 같다.

```c
ch &= 0xff;
```

값 `0xff`는 2진수로 11111111이고, 8진수로 0377이다. 이 마스크는 `ch`의 마지막 8비트만 남기고 나머지를 모두 0으로 설정한다. 따라서 `ch`의 최종값을 1바이트에 넣을 수 있는 값으로 만들어준다. 

### 비트 켜기(비트 설정)

어떤 값의 특정 비트만 켜고, 나머지 비트들은 변경시키지 말아야 할 경우 `|`을 이용하여 특정 비트만 킬 수 있다.

```c
flags |= MASK;
```

### 비트 끄기(비트 삭제)

어떤 값의 특정 비트들만 끄기 위해 `&`를 이용하여 수행하는 연산이다. 

```c
flags &= ~MASK;
```

`flags`가 00001111, `MASK`가 10110110이라고 가정하면 위와 같은 표현식은

```c
(00001111) &^ (10110110) == (00001001)
```

### 비트 토글

토글은 on을 off로, off를 on으로 전환하는 것을 의미한다. XOR 연산자 `^`를 사용하여 비트 토글을 할 수 있다. b가 비트 세팅(1 또는 0)일 때, b가 1이면 1 ^ b는 0이다. b가 0이면 1 ^ b는 1이다. 또한 0 ^ b는 b의 값이 무엇이든 간 그대로 b가 된다. 그러므로, `^`를 사용하여 어떤 값을 마스크와 결합하면, 마스크에 있는 1인 비트에 대응하는 값들은 토글, 0인 비트에 대응하는 값들은 변하지 않는다. 

```c
flags ^= MASK;
```

`flags`가 00001111, `MASK`가 10110110이라고 가정하면

```c
(00001111) &^ (10110110) == {10111001}
```

### 비트 값 검사

`flag`에 있는 비트 1번이 1인지 검사하고자 할 때, `flag`의 비트 1번을 제외한 다른 모든 비트들을 마스크하고 검사를 해야한다.

```c
if((flag & MASK) == MASK) {...}
```

## 비트 단위 시프트 연산자

### 왼쪽 시프트

왼쪽 피연산자의 비트들을 오른쪽 피연산자가 지정하는 자릿수만큼 왼쪽으로 이동시킨다. 비워지는 위치들은 0으로 채워지고 자리 밖으로 밀려나는 비트들은 사라진다.

```c
(10001010) << 2 == (00101000)
```

이 연산은 새로운 비트 값을 만들지만 피연산자를 변경시키지 않는다. 변수의 값을 변경시키려면 대입 연산자를 결합하여 (`<<=`) 사용하면 된다.

### 오른쪽 시프트

비트들을 지정된 자릿수만큼 오른쪽으로 이동시킨다. 자리 밖으로 밀려나는 비트들은 사라진다. 부호 없는(`unsigned`) 데이터의 경우 왼쪽에 비워지는 위치는 0으로 채워지고, 부호 있는(`signed`) 데이터형인 경우의 결과값은 시스템에 따라 다르다.

마찬가지로 변수의 값을 변경시키려면 시프트-대입 결합 연산자(`>>=`)를 이용한다.

```c
value >>= 3;
```

### 용도

어떤 수를 2의 거듭제곱으로 곱하거나 나눌 때 편리하게 사용할 수 있다.

```
number << n: number에 2승씩 곱한다.
number >> n: number가 음수가 아니라면, number를 2의 n승씩 나눈다.
```

# 비트 필드

비트를 조작하는 두 번쨰 방법이다. 비트 필드는 하나의 `signed int`형 또는 하나의 `unsigned int`형 안에 있는 이웃하는 비트들의 집합이다. 비트 필드는 각 필드에 레이블을 붙이고, 그들의 크기를 지정하는 구조체 선언을 통해 설정한다. 

```c
struct {
  unsigned int autfd: 1;
  unsigned int bldfc: 1;
  unsigned int undln: 1;
  unsigned int itals: 1;
} prnt;
```

이 정의는 `prnt`가 1비트짜리 필드 4개를 포함하게 만든다. 보통의 구조체 멤버 연산자를 사용하여 개별적인 필드들에 값을 대입할 수 있다.

```c
prnt.itals = 0;
prnt.undln = 1;
```

이 특별한 필드들은 각각 1비트이기 때문에, 0과 1이 대입에 사용할 수 있는 유일한 두 값이다. 변수 `prnt`는 `int`형 크기의 메모리 셀에 저장된다. 

때로는 하나의 설정에 대해 선택지가 두 개 이상인 경우가 있다. 그런 경우 선택지 모두를 나타내기 위해서는 하나 이상의 비트가 필요하다. 

```c
struct {
  unsigned int code1: 2;
  unsigned int code2: 2;
  unsigned int code3: 8;
} prcode;
```

이 코드는 2비트짜리 필드 2개와 8비트짜리 필드 1개를 만든다. 

레이블이 없는 필드 크기를 지정하여, 레이블이 없는 구멍이 있는 필드 구조체를 매울 수 있다. 레이블이 없는 필드 크기를 0으로 지정하면, 그 다음 오는 필드가 그 다음 정수에 맞게 정렬된다.

```c
struct {
  unsigned int field1: 1;
  unsigned int : 2;
  unsigned int field2: 1;
  unsigned int : 0;
  unsigned int field3: 1;
} stuff;
```

위와 같은 코드에서, `stuff.field1`과 `stuff.field2` 사이에는 2비트의 갭이 있다. 그리고 `stuff.field3`는 그 다음 위치의 `int`에 저장된다.

`int`에 필드들이 들어가는 순서는 컴퓨터 기종마다 다르다. 어떤 기종에서는 왼쪽에서 오른쪽일 수도 다른 기종에서는 반대일 수도 있다. 또한, 필드 사이의 경계들의 위치도 기종마다 다르다. 이런 이유 때문에, 비트 필드는 이식성이 매우 낮다.

# 조정배치(alignment) 기능

이 기능은 바이트 조작에 더 가깝다. `_Alignof` 연산자로 동작하고 이 연산자는 데이터형의 조정배치 조건을 만든다. 

```c
size_t d_align = _Alignof(float);
```

위 코드는 `d_align`의 값이 4일 때, float 객체는 4라는 조정배치 요구가 있는 것이다. 그것은 그 형의 값을 저장하는 연속적인 주소 간 바이트 수가 4라는 의미이다. 일반적으로 조정배치 값들은 2의 음수가 아닌 정수승이어야 한다. 더 큰 조정배치 값들은 더 작은 것들보다 stricter 또는 stronger라는 용어를 쓰고, 반대는 weaker라는 용어를 사용한다.

`_Alignas` 한정자를 사용하여 변수 또는 형(type)에 대한 특별한 조정 배치를 요구할 수 있다. 그러나 그 형(type)에 대한 근본 조정배치 보다 더 약한 조정배치를 요구하면 안된다. `float`에 대한 조정배치가 4라면, 그보다 더 작은 조정배치를 요구하면 안된다. 

```c
_Alignas(double) char c1;
_Aligna(8) char c2;
unsigned char _Alignas(long double) c_arr[sizeof(long double)];
```

```c
#include <stdio.h>

int main(void) {
    double dx;
    char ca;
    char cx;
    double dz;
    char cb;
    char _Alignas(double) cz;

    printf("char 조정배치(alignment): %zd\n", _Alignof(char));
    printf("double 조정배치(alignment): %zd\n", _Alignof(double));
    printf("&dx: %p\n", &dx);
    printf("&ca: %p\n", &ca);
    printf("&cx: %p\n", &cx);
    printf("&dz: %p\n", &dz);
    printf("&cb: %p\n", &cb);
    printf("&cz: %p\n", &cz);

    return 0;
}
```

```
char 조정배치(alignment): 1
double 조정배치(alignment): 8
&dx: 00000041C2DFF808
&ca: 00000041C2DFF807
&cx: 00000041C2DFF806
&dz: 00000041C2DFF7F8
&cb: 00000041C2DFF7F7
&cz: 00000041C2DFF7F0
```

`double`에 대한 조정배치 값이 8이라는 것은 데이터형이 주소를 8로 나눌 수 있는 주소를 조정한다는 뜻이다. 그리고 그것들은 `double`변수 2개와 `char` 변수 `cz`에 사용된 주소들의 종류이다. `char`에 대한 조정배치 값이 1이었기에, 컴파일러는 정규 `char` 변수들에 대한 어떤 주소라도 사용할 수 있다. 

`stalign.h` 헤더 파일을 포함하면 `_Alignas`와 `_Alignof`에 대한 `alignas`와 `alignof`를 사용할 수 있다.

또한 `stdlib.h` 라이브러리 새로운 메모리 할당 함수를 추가함으로써 할당된 메모리에 대한 조정배치 능력도 가져온다. 

```c
void *aligned_alloc(size_t_alignment, size_t_size);
```

첫 번째 매개변수는 요구된 조정배치 값을 상세화하고 두 번째 매개변수는 요구된 바이트 수를 요청한다.(첫 번째 매개변수의 배수이어야 함) `free()`로 할당했던 메모리를 해제해야 한다.