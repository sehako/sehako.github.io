---
title:  "[C] 저장 클래스, 연계, 메모리 관리"
excerpt: "정리"

categories:
  - C

toc: true
toc_sticky: true
 
date: 2023-02-09
---

# 저장 클래스

C는 데이터를 메모리에 적재하기 위해 변수들을 위한 서로 다른 다섯 가지의 기억 모델인 저장 클래스(storage class)를 제공한다. 

메모리에 저장된 값은 물리적인 메모리를 차지한다. 이런 것을 C 에서는 객체(object)라고 한다.(객체 지향과는 다른 개념으로 봐야 함) 객체는 하나 또는 그 이상의 값들을 저장한다. 

프로그램은 이런 객체에 접속하는 방법을 필요로 한다. 그렇기에 변수 이름(식별자)을 선언하는 것이다. 식별자를 통해 하드웨어 메모리에 저장된 객체를 소프트웨어가 가리키는 것이다. 변수의 이름(식별자)을 통해서만 객체를 지정하는 것은 아니다.

```c
int * ptr = &entity;
int arr[10];
```

`ptr`라는 식별자는 주소를 갖는 객체를 지정한다. 그러나 `* ptr`은 식이기 때문에 식별자가 아니다. 그럼에도 불구하고, `entity`와 동일한 객체를 지정한다. 객체가 지정하는 식은 좌변값이라고 부른다. 따라서 `entity`는 좌변값인 식별자이며, `*ptr`은 좌변값인 식이다.

`arr`의 선언은 정수형 10개를 저장하도록 만들 수 있고, 이런 배열의 각 원소는 객체를 만든다.

## 저장 수명(storage duration)
객체가 얼마나 메모리에 유지될 수 있는지를 나타낸다. 범위(scope)와 (linkage)로 객체를 접속하는데 사용된 식별자를 설명한다면, 이 둘은 함께 한 프로그램의 어떤 부분들이 그것을 사용할 수 있는지를 정한다. 저장 클래스에 따라 범위, 연꼐, 저장 기간의 다른 조합이 만들어진다. 

### 범위
프로그램이 어떤 식별자에 접근할 수 있는 영역을 나타낸다. C의 변수는 블록 범위, 함수 프로토타입 범위, 파일 범위 중 어느 한 가지 범위를 가진다. 블록 범위는 코드 내 `{}`안에 정의된 변수를 말한다.

함수의 범위는 `goto`와 함께 사용되는 레이블(label)에만 적용된다. 이것은 함수에서 안쪽 블록 안에서 레이블이 맨처음 나타나더라도, 그것의 범위는 전체 함수로 확장된다.

함수 프로토타입 범위는, 함수 프로토타입에 사용되는 변수 이름들에 적용된다.

```c
void function(int value);
```

변수들이 정의된 지점부터 프로토타입 선언의 끝까지가 범위다. 함수 프로토타입 전달인자를 처리할 때 컴파일러는 오직 데이터형에만 관심을 가진다는 것이다.

정의가 어떤 함수에도 속하지 않고 함수들의 바깥에 놓여 있는 변수는 파일 범위를 가진다. 이는 정의된 지점부터 끝까지 적용된다.

```c
#include <stdio.h>

int value = 0;
void function(void);

int main(void) {

  return 0;
}

void function() {

}
```

`value`는 파일 범위를 가진다. 따라서 `main()`과 `function()`에서 모두 사용 가능하다. (좀 더 정확하게 하자면, `value`는 외부 연계와 파일 범위가 있음) 이런 변수들을 전역 변수(global variable)이라고 한다.

### 연계
C의 변수는 외부 연계, 내부 연계, 무연계 중 어느 하나를 가진다. 블록 범위 변수나 함수 범위 변수, 즉 함수 프로토타입 범위 변수는 연계를 가지지 않는다. 다시 말해서 정의된 블록이나 함수(프로토타입)에만 적용된다는 뜻이다.

파일 범위 변수는 내부 연계나 외부 연계 중 어느 하나를 가질 수 있다. 외부 연계를 가지는 변수는, 다중 파일 프로그램의 어디에서나 사용할 수 있다. 내부 연계를 가지는 변수는, 한 파일 안의 어디에서나 사용할 수 있다. 파일 범위 변수의 연계는 저장 클래스 지정자인 `static`에 의해 구분된다.

```c
#include <stdio.h>
int value = 0;  //파일 범위, 외부 연계
static int var = 0; //파일 범위, 내부 연계

int main(void) {

  return 0;
}
```

`value`는 동일한 프로그램을 구성하는 다른 파일들에서도 사용할 수 있다. `var`은 해당 코드(파일) 내에서만 유효하고, 모든 함수들이 사용할 수 있다.

이런 범위와 연계는 식별자의 가시성을 설명하는 부분이다.

### 저장 수명
식별자들로 접속하는 객체들의 지속성을 나타낸다. C 객체는 네 가지 수명(정적 수명, 스레드 수명, 자동 수명, 할당된 수명) 중 한 가지를 가지고 있다.

정적 수명을 갖는 객체는 프로그램이 실행되는 동안에 내내 존재한다. 모든 파일 범위 변수들은 정적 수명을 갖는다. 또한 파일 범위 변수에 대해서 사용되는 `static`은 수명이 아닌 연계 유형을 나타낸다.

스레드 수명은 프로그램 실행이 여러 스레드로 분할 될 수 있는 동시 프로그래밍으로 실행하게 된다. 스레드 수명은 그것이 실행 이후 종료될 떄까지 존재한다. 이런 객체는 파일 범위 객체가 선언되거나 키워드(`_Thread_local`)로 수정되는 파일 범위 객체가 생성될 떄 만들어진다. 해당 키워드 지정자로 선언된 변수는, 스레드에서 변수의 자체 비밀 복사본을 갖는다.

블록 범위 변수는 일반적으로 자동 수명을 갖는다. 정의된 블록에 진입할 때 메모리가 할당되고, 블록을 탈출할 때 메모리가 해제된다. 따라서 자동 변수에 사용되는 메모리는 재사용 할 수 있는 워크스페이스 또는 스크래치패드라는 것을 의미한다. 

변수 길이 배열은 블록의 시작부터 끝까지 라기 보다 블록이 선언된 지점으로부터 블록의 끝까지 존재하는 약간의 예외를 둔다.(???)

모든 지역 변수들은 자동 수명을 가진다. 아래 예제에 나오는 두 변수는 함수의 호출 떄 새로 생성되고, 실행 종료 시 소멸된다.

```c
int function(int var) {
  int a;
  a + var;
  return a;
}
```

그러나 변수는 블록 범위를 가지는 동시에 정적인 수명을 가질 수 있다. 키워드 `static`을 선언에 추가한다.

```c
void function(int var) {
  static int num = 0;

  return 0;
}
```

변수 `num`는 정적 메모리에 저장된다. 따라서 `function` 함수가 실행되고 있는 동안 프로그램은 그것이 지정하는 객체에 접속할 수 있도록 ct를 사용할 수 있다. 예를 들어, 함수가 포인터 매개변수나 리턴 값으로 다른 함수들에 저장 주소를 제공할 수 있도록 간접 접속을 허용할 수 있다. 

### 범위, 연계, 저장 수명에 관한 표
|저장 클래스|수명|범위|연계|선언 방법
|:---:|:---:|:---:|:---:|:---:|
자동|자동|블록|없음|블록 내 선언
레지스터|자동|블록|없음|블록 내 키워드 `register`로 선언
정적 외부 연계|정적|파일|외부|모든 함수들의 바깥에 선언
정적 내부 연계|정적|파일|내부|모든 함수들의 바깥에 키워드 `static`으로 선언
정적 무연계|정적|블록|없음|블록 내 키워드 `static`으로 선언

## 자동 변수
자동 저장 클래스에 속하는 변수는 자동 수명, 블록 범위, 무연계를 가진다. 블록 내에 또는 함수 머리 안에 선언된 변수는 기본적으로 자동 저장 클래스에 속한다. 그러나 의도를 확실하게 하기 위해 `auto` 키워드(저장 클래스 지정자)를 명시적으로 사용할 수 있다.

```c
int main(void) {
  auto int var;
}
```

이는 외부 변수 정의를 의도적으로 무시한다는 것을 나타내거나, 그 변수를 다른 저장 클래스로 바꾸면 안된다는 것을 명시적으로 나타내고자 할 때 사용할 수 있다. C++는 약간 다른 용도로 `auto` 키워드를 재사용하였으므로, 저장-클래스 지정자로서 C/C++ 호환성을 위해 `auto`를 사용하지 않는 것이 더 낫다.

자동 변수는 사용자가 명시적으로 초기화해야한다. 

## 레지스터 변수

CPU 레지스터에 또는 좀 더 일반적으로 사용할 수 있는 가장 빠른 메모리에 저장된다. 따라서 보통의 변수보다 더 빠르게 접근할 수 있고 처리될 수 있다. 레지스터에 저장될 가능성이 높기 떄문에, 해당 변수의 주소는 얻을 수 없다. 그 밖 대부분의 측면에서 레지스터 변수는 자동 변수와 같다.(블록 범위, 무연계, 자동 수명) `register` 저장 클래스 지정자를 사용하여 선언한다.

```c
int main(void) {
  register int num;

  return 0;
}
```

레지스터에 저장될 '가능성'이 높다는 표현은, 레지스터 저장 클래스로 변수를 선언하는 것은 강제성을 띄지 않기 때문이다. 따라서 이 결정은 컴파일러에 달렸다. 레지스터 변수가 되지 않으면 그저 일반적인 자동 변수가 된다. 하지만 그럼에도 주소 연사자를 사용할 수 없다. 레지스터 변수는 형식매개변수에서도 사용 가능하다.

```c
void function(register int n)
```

레지스터 변수는 시스템의 레지스터의 크기(?)에 따라서 제한이 있을 수 있다.

## 블록 범위 정적 변수

static이 의미하는 것은 변수가 메모리에 그대로 유지된다는 것이다. 그러나 반드시 값으로 유지된다는 것은 아니다. 파일 범위 변수들은 자동으로 정적 수명을 가진다. 그리고 정적 수명을 가지는 블록 범위의 지역 변수도 생성할 수 있다. 이런 변수들은 블록 범위, 무연계, 정적 수명을 가진다. 컴퓨터는 한 번의 함수 호출에서 다음 번의 함수 호출까지 그 값들을 기억한다. 선언 방법은 블록 내 변수 선언 시 `static` 키워드를 사용하는 것이다.

```c
void function(void) {
  static int num = 0;

  return 0;
}
```

예제를 통해 좀 더 쉽게 알 수 있다.

```c
#include <stdio.h>

void function(void);

int main(void) {
    for (int i = 0; i <= 3; i++) {
        printf("사이클: %d\n", i);
        function();
    }

    return 0;
}

void function(void) {
    int value = 1;
    static int var = 1;

    printf("%d  %d\n", value++, var++);
}
```

```
사이클: 0
1  1
사이클: 1
1  2
사이클: 2
1  3
사이클: 3
1  4
```

`var`은 컴파일 시 단 한 번 초기화되기에 증가 연산자의 결과를 유지한다. 그리고 정적 변수는 사용자가 명시적으로 어떤 다른 값으로 초기화시키지 않는다면, 0으로 초기화된다. 그런데 위 코드에서

```c
int value = 1;
static int var = 1;
```
의 부분을 보면 런타임 동작에 의해 정적 변수 역시 계속해서 1로 초기화되야 할 것 같다. 하지만 두 번쨰 문장은 사실 `function()`의 일부분이 아니다. 디버깅을 사용하여 프로그램을 차근차근 보면, 프로그램이 해당 단계를 건너뛴다. 프로그램이 메모리에 적재된 이후에는, 정적 변수와 외부 변수들이 이미 자리를 차지하고 있기 때문이다. `function()` 내부에 선언한 이유는, 그것만이 인식하고 허용하라고 컴파일러에게 알리는 것이다.

함수 매개변수에는 `static`을 사용할 수 없다.

## 외부 연계 정적 변수

파일 범위, 외부 연계, 정적 수명을 가지는 이 저장 클래스는 떄로는 외부 저장 클래스라고 부르고, 이 유형의 변수들을 외부 변수라고 부른다. 쉬운 문서화를 위해서, 외부 변수는 키워드 `extern`을 사용하여 그 변수를 사용하는 함수 안에 추가로 재선언할 수 있다. 변수가 다른 파일에 정의되어 있다면 반드시 `extern`을 키워드로 선언해야 한다.

특정 외부 변수가 한 소스 코드에 정의되어 있고 두 번쨰 소스 코드 파일에 사용된다면, 반드시 두 번쨰 파일에 extern으로 변수를 선언해야 한다. 

```c
int value;  //외부적으로 정의된 변수
double var[100];  //외부적으로 정의된 배열
extern char chr;  //필수적인 선언, chr이 다른 파일에 정의되어 있다고 간주

void next(void);
int main(void) {
  extern int value; //선택적인 재선언
  extern double var[];  //선택적인 재선언
}

void next(void) {

}
```

`double` 배열 `var`에 대한 선택적인 추가 선언에서는 크기를 지정할 필요가 없다. 최초의 선언이 이미 그 정보를 제공했기 떄문이다. `main()` 내 `extern datatype` 선언들은 완전하게 생략 가능하다. 선택적 재선언들은 `main()`에서 이 변수들을 사용한다는 의도를 문서화한다는 용도로 사용된다. 만약 `int value`와 같이 선언한다면 `main()`내 새로운 자동 변수를 생성한다. 이 경우 해당 지역 변수가 전역 변수를 가려버린다.

외부 변수는 명시적으로 초기화 하지 않으면 자동으로 0으로 초기화된다. 이런 규칙은 외부적으로 정의된 배열의 원소들에도 적용된다. 자동 변수의 경우와는 다르게, 파일 범위 변수를 초기화할 때 상수 표현식만을 사용할 수 있다.

### 외부 변수의 정의와 선언

변수를 정의하는 것과 변수를 선언하는 것의 차이가 있다. 

```c
int value = 1;  //value가 정의되어 있음

int main(void) {
  extern int value; //어딘가에 정의되어 있는 value를 사용
}
```

여기서 `value`의 첫 번째 선언은 그 변수를 위해 기억 장소를 할당하는 정의를 구성한다.(정의 선언) 두 번째 선언은 단지 컴파일러에게 이미 생성되어 있는 `value`를 사용하라고 알린다.(참조 선언)

```c
extern int value;

int main(void) {

}
```

다음과 같은 선언은 컴파일러는 `value`의 실제 정의가 프로그램의 아마 다른 파일에 있을 것이라고 가정한다. 이런 선언은 기억 공간을 할당하지 않는ㄴ다. 그러므로 외부 정의를 생성하려면 키워드 `extern`을 사용하지 않는다. 

외부 변수는 정의될 떄 단 한 번만 초기화할 수 있으므로 `extern` 사용 시 변수를 초기화 하는 것은 에러로 간주된다.

```c
// file.c
char value = 'A';

// other.c
extern char value = 'B';  //Error!
```

## 내부 연계 정적 변수
정적 수명, 파일 범위, 내부 연계를 가지는 저장 클래스로, 어떤 함수에도 속하지 않고 함수들의 바깥에 저장 클래스 지정자 `static`을 사용하여 정의한다.

```c
static int value = 1;

int main(void) {
  extern int value; 

  return 0;
}
```

외부 변수와의 차이점은 해당 변수는 선언된 파일 내에서만 사용이 가능하다는 것이다. 이는 여러 소스 코드를 사용하는 C 프로그램에서 나타나는 차이점이다.

# 저장 클래스 지정자 총괄
C 언어는 저장 클래스 지정자로 묶을 수 있는 여섯 가지 키워드(`auto`, `register`, `static`, `extern`, `_Thread_local`, `typedef`)를 제공한다. 선언에는 하나의 저장 클래스 지정자만 사용할 수 있다. 한 가지 예외는 바로 `_Thread_local`이 `static`, `extern`과 함께 사용될 때이다. 

`auto` 지정자는, 자동 수명을 가지는 변수를 나타낸다. 이미 자동 수명을 가지고 있는 블록 범위 변수의 선언에만 사용할 수 있으므로, 주된 의도는 바로 문서화 용도이다.

`register` 지정자 또한 블록 범위 변수에만 사용할 수 있다.

`static` 지정자는 정적인 수명을 가진 객체를 만든다. 파일 범위 선언과 함께 사용되면, 범위는 그 한 파일로 제한되고 내부 연계가 없다. 블록 범위 선언과 함께 사용되면 범위는 그 블록에 제한되고 연계가 없다. 객체가 존재하고 프로그램이 실행되는 한 그 값을 유지하지만, 블록 내 코드가 실행되고 있을 때만 식별자가 객체에 접속할 수 있다. 

`extern` 지정자는 어딘가에 이미 정의되어 있는 변수를 재선언 한다는 것을 나타낸다. 참조되는 변수는 정의 선언이 어떠냐에 따라서 내부 연계와 외부 연계 둘 중 어느 하나를 가질 수 있다.

# 저장 클래스와 함수

함수도 저장 클래스를 가진다. 함수는 외부(디폴트) 또는 정적 둘 중 어느 하나를 가질 수 있다. 외부 함수는 다른 파일에 들어 있는 함수들이 사용할 수 있다. 그러나 정적 함수는 그 함수가 정의된 파일에 들어 있는 함수들만이 사용할 수 있다. 

```c
void function();  //(디폴트) 외부 함수
static void beta();
extern void delta();
```

다음 선언이 존재할 때, `beta()` 함수를 제외한 다른 함수는 모두 다른 파일에서 사용할 수 있다. `static` 저장 클래스를 사용하는 한 가지 이유는, 함수들을 특정 모듈에만 사용할 수 있게 만들어 이름들이 충돌할 가능성을 피하는 것이다.

다른 파일에 정의되어 있는 함수를 선언할 때 관례적으로 키워드 `extern`을 사용한다. 

안전한 프로그래밍을 위한 황금률 중 하나는, 공유할 필요가 있는 변수들만 공유하면서, 각 함수들의 작업을 가능하면 해당 함수에만 국한시키는 것이다.(Need to know rule)

