---
title:  "[C] 메모리 관리"
excerpt: " "

categories:
  - C

toc: true
toc_sticky: true
 
date: 2023-02-11
---

# 할당된 메모리 malloc() & free()

프로그램을 실행할 때 사용자가 메모리를 할당할 수 있다. 이 작업을 위해 사용하는 도구가 `malloc()` 함수다. 하나의 전달인자로 원하는 만큼의 메모리 바이트 수를 사용한다. 그러면 `malloc()`은 자유 메모리 공간에서 적당한 블록을 찾는다. 하지만 `malloc()`은 메모리를 할당하지만 거기에 이름을 붙이지 않는 익명이고, 할당한 블록의 첫 번째 주소를 리턴한다. 그러므로 포인터 변수에 그 주소를 대입할 수 있다. 

`malloc()` 함수는 배열, 구조체, 기타 등등을 가리키는 포인터를 리턴할 수 있다. 일반적으로 그 리턴값은 데이터형 캐스트를 사용하여 적당한 값으로 변환된다. 그러나 `void`형을 가리키는 포인터 값을 다른 데이터형을 가리키는 포인터에 대입하는 것은 데이터형 충돌로 간주되지 않는다. `malloc()`은 적당한 메모리 공간을 찾지 못하면 NULL 포인터를 리턴한다. 

이해하기 위해 배열을 생성하는 작업에 `malloc()`을 사용해본다. 

```c
double * ptr;
ptd = (double *) malloc (30 * sizeof(double));
```

위 코드는 30개의 double형 값을 저장하기 위한 공간을 요청하고, `ptr`이 그 위치를 가리키도록 설정한다. 여기서 `ptr`이 `double`형 값 30개를 가지는 블록을 가리키는 포인터가 아닌, 하나의 `double`형 값을 가리키는 포인터로 선언된 것에 유념한다. 그리고 배열 이름은 첫 번째 원소의 주소라는 것 또한 유념한다.

`malloc()`은 `free()`와 함께 사용해야 한다. `free()`함수는 바로 전 `malloc()`이 리턴했던 주소를 전달인자로 사용하여, 할당했던 메모리를 해제한다. 그래서, 할당된 메모리의 수명은, `malloc()`의 호출부터 `free()`의 호출로 재사용할 수 있도록 메모리를 해제하는 시점까지다.

`free()`는 항상 `malloc()`에 의해 할당된 메모리를 해제하는 용도로 사용된다. 이 두 함수는 `stdlib.h`에 정의되어 있다. 두 함수에 관한 예제가 존재한다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    double * ptd;
    int max;
    int number;
    int i = 0;

    puts("몇 개의 double을 입력할건지?");

    if (scanf_s("%d", &max) != 1) {
        puts("숫자가 정확하게 입력되지 않았습니다.");
        exit(EXIT_FAILURE);
    }
    ptd = (double *) malloc(max * sizeof(double));  //가변 배열 선언

    if (ptd == NULL) {
        puts("메모리 할당에 실패했다.");
        exit(EXIT_FAILURE);
    }

    puts("값들을 입력하시오(q입력시 종료)");

    while (i < max && scanf_s("%lf", &ptd[i]) == 1) {
        ++i;
    }
    printf("입력한 %d개의 값들은 다음과 같다\n", number = i);

    for (i = 0; i < number; i++) {
        printf("%7.2f", ptd[i]);
        if(i % 7 == 6) {
            putchar('\n');
        }
    }
    if(i % 7 != 0) {
        putchar('\n');
    }
    puts("종료");
    free(ptd);  //할당 해제

    return 0;
}
```

```
몇 개의 double을 입력할건지?
5
값들을 입력하시오(q입력시 종료)
123.
22.3
323.1
23
4123.2
입력한 5개의 값들은 다음과 같다
 123.00  22.30 323.10  23.004123.20
종료
```

위 코드에서 `exit()` 함수는 프로그램의 종료를 수행한다. 값 `EXIT_FAILURE` 또한 `stdlib.h` 헤더에 정의되어 있다. 프로그램의 정상적 종료는 `EXIT_SUCCESS`(또는 0), 비 정상적 종료는 `EXIT_FAILURE`이다.

데이터형 캐스트 `(double *)`는 C에서는 선택이고 C++에서는 필수이다. 

## free()의 중요성

정적 메모리의 양은 컴파일 시 고정된다. 그것은 프로그램이 실행되는 동안 변하지 않는다. 자동 변수에 의해 사용되는 메모리의 양은 유동적이다. 그러나 할당된 메모리에 의해 사용되는 메모리의 양은, 사용자가 `free()`를 사용하는 것을 잊으면 계속 커진다. 

```c
int main(void) {
    double glad[2000];
    int i;

    for (i = 0; i < 1000; i++) {
        gobble(glad, 2000);
    }
}

void gobble(double ar[], int n) {
    double * temp = (double *) malloc(n * sizeof(double));
    //free(temp);
}
```
위와 같은 코드가 존재한다면, `temp`는 자동 변수이기 때문에 소멸한다. 그러나 그것이 가리키던 메모리를 해제한다는 것은 아니다. 주소를 더 이상 가지고 있지 않기 떄문에, 16,000바이트의 메모리에는 이제 접근할 수 없다. 

이런 루프가 1000번 실행되면 16,000,000 바이트의 메모리가 메모리 풀에서 미아 상태가 된다. 실제로는 이 상황에 도달 전 프로그램이 메모리를 전부 소모할 것이다. 이런 메모리 누출(memory leak) 문제를 피하기 위해서 `free()`가 중요하다.

# calloc() 함수

메모리를 할당하는 또 한가지 방법이다.

```c
long * ptr;

ptr = (long *) calloc(100, sizeof(long));
```

위 함수는 두 가지 전달인자를 사용한다. 첫 번쨰 전달인자는 사용자가 원하는 메모리 셀의 개수이다. 두 번쨰 전달인자는 각 셀의 바이트 수이다. 따라서 위와 같은 코드는 `long`형의 크기(4 바이트)만큼의 메모리 단위를 100개 요청하여 총 400바이트를 할당한다.

`calloc()`은 할당된 블록의 모든 비트들을 0으로 설정한다. (그러나 일부 하드웨어 시스템은, 부동소수점 값 0을 모든 비트들을 0으로 설정하는 것으로 나타내지 않는다.)

`free()` 함수는 `calloc()`에 의해 할당된 메모리를 해제하는 데에도 사용할 수 있다.

# 저장 클래스와 동적 메모리 할당

저장 클래스와 동적 메모리 할당 사이의 관꼐를 알기 위해서, 우선 이상적인 모델을 구성해야 한다. 외부 연계, 내부 연계, 무연계 정적 변수를 위한 메모리 영역, 자동 변수를 위한 메모리 영역, 동적으로 할당되는 메모리 영역 이렇게 세 가지 영역으로 사용 가능한 메모리를 프로그램이 나눈다고 가정한다.

정적 수명 저장 클래스들에 필요한 메모리의 양은 컴파일 시 결정된다. 그리고 이 영역에 저장되는 데이터는 프로그램이 실행되는 동안 계속 사용 가능하고 프로그램이 종료될 때 소멸된다.

자동 변수는 프로그램이 그 변수의 정의를 포함하고 있는 코드 블록에 진입할 때 생성되고, 프로그램이 블록을 탈출할 떄 소멸된다. 그렇기에 이 메모리 영역은 항상 가변적이다. 또한 일반적으로 스택으로 처리되기 떄문에 새로운 변수들이 생성되는 순서대로 메로리에 추가되고, 소멸될 떄에는 반대 순서로 소멸된다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int static_store = 30;
const char * pcg = "String Literal";

int main(void) {
    int auto_store = 40;
    char auto_string[] = "Auto char Array";
    int * pt;
    char * pcl;

    pt = (int *) malloc(sizeof(int));
    *pt = 35;
    pcl = (char *) malloc(strlen("Dynamic String") + 1);
    strcpy(pcl, "Dynamic String");

    printf("static_store: %d at %p\n", static_store, &static_store);
    printf("auto_store: %d at %p\n", auto_store, &auto_store);
    printf("*pt: %d at %p\n", *pt, pt);
    printf("%s at %p\n", pcg, pcg);
    printf("%s at %p\n", auto_string, auto_string);
    printf("%s at %p\n", pcl, pcl);
    printf("%s at %p\n", "Quoted String", "Quoted String");
    free(pt);
    free(pcl);

    return 0;
}
```

```
static_store: 30 at 00007FF715C34020
auto_store: 40 at 0000001E937FFDAC
*pt: 35 at 000001999F741400
String Literal at 00007FF715C35050
Auto char Array at 0000001E937FFD90
Dynamic String at 000001999F745550
Quoted String at 00007FF715C350A6
```

문자열 리터럴을 포함하는 정적 데이터는 한 영역을, 자동 데이터는 두 번째 영역을, 동적으로 할당된 데이터는 세 번째 영역(메모리 힙 또는 프리 스토어)을 차지하고 있다.

# ANSI C 데이터형 한정자

데이터형 한정자들은 멱등(idempotent)이 성립한다. 이것은 한 선언에 동일한 한정자를 여러 번 중복하여 사용할 수 있다는 것과, 남아도는 한정자들은 무시된다는 것을 의미한다.

## const 데이터형 한정자

`const`는 변수를 상수화시켜 값을 변경할 수 없도록 만든다. 따라서 변수를 읽기전용으로 만든다. 

```c
const int value = 5;
value = 10; //Error!
```

### 포인터와 매개변수 선언에 const 사용

포인터의 경우 `const`가 조금 복잡하다. 포인터 자체를 `const`로 만드는 것과 포인터가 가리키는 값을 `const`로 만드는 것을 구별해야 하기 떄문이다. 

```c
const float * ptr;
//또는
float const * ptr;
```

위와 같은 코드는 `ptr`이 항상 상수로 유지해야 하는 `float`형 값을 가리키게 만든다. `ptr` 자체의 값은 변경될 수 있다. 

```c
float * const ptr;
```

위와 같은 코드는 포인터 자체의 값을 변경할 수 없다. `ptr`은 항상 같은 주소를 가리켜야 한다. 그러나 `ptr`이 가리키는 값은 변경할 수 있다. 

```c
const float * const ptr;
```

따라서 이런 선언은 `ptr`이 항상 같은 주소를 가리켜야 하고, 그 위치에 저장되어 있는 값도 변경하면 안된다는 것을 의미한다.

이런 방법의 흔한 사용 방법은, 함수의 형식매개변수 역할을 하는 포인터를 선언하는 것이다. 배열의 내용을 표시하는 함수를 정의할 떄 단순하게 배열의 이름만을 함수에 전달한다면, 함수는 배열의 내용까지 변경이 가능하다. 배열의 이름은 주소이기 떄문이다. 이를 방지하고자 다음과 같이 함수 프로토타입을 선언할 수 있다.

```c
void display(const int array[], int limit);
```

`const int arrayp[]`는 `const int * array`와 같다. 따라서 이런 선언은 array가 가리키는 데이터는 변경할 수 없다.

### 전역 데이터에 const 사용

전역 변수의 데이터 변질을 막기 위해 `const` 제한자를 사용하는 것은 매우 바람직하다. `const`를 이용하여 변수, 배열, 구조체 등을 만들 수 있다.

그러나 `const` 데이터를 여러 파일에 걸쳐서 공유하는 것이 필요한 조심스러운 분야가 있다. 이럴 떄 두 가지 전략을 사용할 수 있다. 첫쨰 방법은 외부 변수에 적용되는 유용한 규칙을 따르는 것이다. 하나의 파일에 정의 선언을 넣고, 다른 파일들에서는 (`extern` 키워드를 사용하는) 참조 선언을 사용하는 것이다.

```c
//file1.c
const double PI = 3.14159;
const char * MONTHS[12] = {
    "1월", "2월", "3월", "4월", "5월", "6월", "7월", 
    "8월", "9월", "10월", "11월", "12월" 
};

//file2.c
extern const double PI;
extern const * MONTHS[];
```

두 번쨰 방법은, 상수들을 `include` 파일에 넣는 것이다. 여기서는 정적 외부 기억 부류를 사용하게 만드는 부가적인 단계를 거쳐야 한다.

```c
// constant.h에 몇 개의 전역 상수들을 정의
static const double PI = 3.14159;
static const char * MONTHS[12] = {
    "1월", "2월", "3월", "4월", "5월", "6월", "7월", 
    "8월", "9월", "10월", "11월", "12월" 
};

//file1.c
#include "constant.h"

//file2.c
#include "constant.h"
```

`static`을 사용하지 않고 `file1.c`와 `file2.c`에 `constant.h`를 포함시키면, 동일한 식별자의 정의 선언이 각 파일에 들어가는 결과를 가져온다. ANSI 표준은 이것을 지원하지 않는다.

헤더 파일 방식의 장점은, 하나의 파일에 정의 선언들을 사용하고, 다른 파일들에 참조 선언들을 사용해야 한다는 것을 기억할 필요가 없다는 것이다. 

다만 데이터가 중복된다는 단점이 있어, 상수 데이터가 엄청난 크기의 배열을 포함하는 경우 문제가 될 수 있다.

## volatile 데이터형 한정자

어떤 변수가 프로그램이 아닌 다른 대행자에 의해 그 값이 변경될 수 있다고 컴파일러에게 알린다. 일반적으로 그것은 하드웨어 주소 또는 동시에 실행되는 여러 프로그램들이 공유하는 데이터에 사용된다. 

예를 들어, 어떤 주소에 현재의 클록 시각이 담겨 있을 수 있다. 그 주소에 들어 있는 값은, 프로그램이 하는 일과는 무관하게 시간이 변함에 따라 변한다. 또는 어떤 주소가 다른 컴퓨터로부터 전달된 정보를 저장하는 데 사용될 수 있다.

```c
volatile int loc1;  // loc1은 volatile 위치
volatile int * ploc;    // ploc는 volatile 위치를 가리킴
```

위 코드는 `loc1`이 어떤 `volatile` 값이고, `ploc`는 `volatile` 값을 가리키는 포인터라고 선언한다.

이 데이터형 한정자는 컴파일러의 최적화를 지원하기 위해 존재한다.

```c
val1 = x;
//x를 사용하지 않는 코드 부분
val2 = x;
```

최적화된 컴파일러는 값 x를 변경시키는 일 없이 두 번 사용하고 있다는 것으로 간주한다. 컴파일러는 값 `x`를 레지스터에 임시로 저장할 것이다. 그러고 나서, `val2`를 위해 `x`를 사용할 필요가 있을 떄, 원래 메모리 위치 대신에 레지스터에서 그 값을 읽음으로써 시간을 절약할 수 있다.(Cashing) 일반적으로 캐싱은 두 명령문 사이에서 다른 대행자에 의해 `x`가 변경되지 않을 경우에만 좋은 최적화이다. `volatile` 키워드의 등장 이후, 해당 키워드가 선언에 사용되지 않으면, 컴파일러는 어떤 값이 한 번 사용되고 나서 다시 사용되기 전에 변경되지 않았다고 가정할 수 있다. 그래서 코드 최적화를 시도할 수 있다.

하나의 값은 `const`이면서 동시에 `volatile`일 수 있다. 예를 들어, 일반적으로 하드웨어 클록 설정은 프로그램에 의해 변경되면 안되므로 `const`로 만든다. 그러나 프로그램이 아닌 다른 대행자에 의해 변경되므로 `volatile`로 만든다. 두 개의 한정자를 다음과 같이 사용한다. 순서는 문제가 되지 않는다.

```c
volatile const int loc;
const volatile int * ploc;
```

## restrict 데이터형 한정자

컴파일러가 특정 유형의 코드를 최적화할 수 있도록 허용함으로써 계산 능력을 향상시킨다. `restrict` 키워드는 포인터에만 적용할 수 있다. 그것은 그 포인터가 어떤 데이터 객체에 접근하는 유일한 최초 수단이라는 것을 나타낸다. 

```c
int ar[10];
int * restrict restar = (int *) malloc(10 * sizeof(int));
int * par = ar; 
```

여기서, 포인터 `restar`는 `malloc()`에 의해 할당된 메모리에 접근할 수 있는 유일한 최초 수단이다. 그러므로 이것을 `restrict` 키워드로 한정할 수 있다. 그러나 포인터 `par`은 `ar` 배열에 있는 데이터에 접근할 수 있는 유일한 수단도 아니고 최초 수단도 아니다. 따라서 포인터 `ar`은 `restrict` 키워드로 한정할 수 없다.

```c
for (n = 0; n < 10; n++) {
    par[n] += 5;
    restar[n] += 5;
    ar[n] *= 2;
    par[n] += 3;
    restar[n] += 3;
}
```

위 예시에서 `restar`가 그것이 가리키는 데이터블록에 접근할 수 있는 유일한 최초 수단이라는 것을 알기 떄문에, 컴파일러는 `restar`를 사용하는 두 개의 문장을, 동일한 효과를 내는 하나의 문장으로 대체할 수 있다.

```c
restar[n] += 8;
```

그러나 `par`를 사용하는 두 개의 명령문을 하나의 문장으로 대체하면 계산 에러가 발생한다.

```c
par[n] += 8; 
```

이것이 다른 답을 주는 이유는, `par`가 동일한 데이터에 두 번 접근하는 그 사이에 루프가 `ar`을 사용하여 그 데이터의 값을 변경하기 떄문이다.

`restrict` 키워드는 함수 매개변수로 사용되는 포인터에도 한정자로 사용할 수 있다. 이것은, 함수 몸체 안에서 그 포인터가 가리키는 데이터를 다른 식별자로 수정할 수 없다는 것과, 다른 방법으로는 불가능한 최적화를 컴파일러가 시도할 수 있다는 것을 의미한다. 예를 들어, C 라이브러리는 한 위치에서 다른 위치로 바이트들을 복사하는 두 함수를 제공한다. 이것들은 다음과 같은 프로토타입을 가진다.

```c
void * memcpy(void * restrict s1, const void * restrict s2, size_t n);
void * memmove(void * s1, const void * s2, size_t n);
```

두 함수 모두 `s2` 위치에서 `s1` 위치로 n바이트를 복사한다. `memcpy()`는 두 위치 사이에 겹치는 부분이 없을 것을 요구한다. `memmove()`는 그것을 요구하지 않는다. `s1`과 `s2`를 `restrict`로 선언하는 것은, 각 포인터가 그것이 가리키는 위치에 접근할 수 있는 유일한 수단이라는 것을 의미한다. 그래서 두 포인터는 동일한 데이터 블록에 접근할 수 없다.

## _Atomic형 한정자(C11)

동시 프로그래밍은 프로그램 실행을 병렬로 할 수 있도록 스레드로 나눈다. 그러면 같은 데이터에 접속하는 서로 다른 스레드들을 관리하는 방법 등을 포함한 여러 가지 프로그래밍 상의 도전이 생긴다. C11은 필요가 아닌 선택으로, 선택적 헤더 파일 `stdatomic.h`와 `threads.h`에 의한 관리 방법을 제공한다. 한 측면은 다양한 매크로 함수들에 의해 조정되는 접근이 어느 것인지에 대한 `atomic`형의 개념이다. 스레드가 `atomic`형의 객체 사의 `atomic` 작동을 수행하는 스레드라면 다른 스레드들은 그 객체에 접속하지 않는다.

```c
int value;
value = 10;
// 다음과 같이 교체될 수 있음
_Atomic int value;
atomic_store(&value, 10);
```

`value`내의 값 10을 저장하는 것은 다른 스레드들 동안에 `value`에 접속하지 않으려는 `atomic`과정이다. 

<!-- # 기존 키워드를 놓을 새로운 위치 -->