---
title:  "[C] 파일 입출력"
excerpt: "정리"

categories:
  - C

toc: true
toc_sticky: true
 
date: 2023-02-12
---

파일(file)은 일반적으로 이름이 붙어 있는 디스크 상의 어떤 영역이다. 운영체제의 관점에서는 조금 복잡한데, 하나의 파일이 여러 영역에 나뉘어 저장되어 있을 수도 있고 어떤 종류의 파일인지 운영체제가 판단할 수 있는 부가적인 데이터가 파일 안에 들어있을 수도 있다.

C에서는 파일을, 각 바이트를 개별적으로 읽을 수 있는, 연속적인 바이트들의 시퀀스로 인식한다. 이것은 C의 성장 배경이었던 Unix 환경에서의 파일 구조와 일치한다. 다른 환경들은 이런 모델과 일치하지 않을 수 있기에 파일을 텍스트 인식과 바이너리 인식을 제공한다.

# 텍스트 모드와 바이너리 모드

모든 파일 컨텐츠는 2진법의 형태로 이루어져 있다. 그러나 파일이 C 문자열만큼 많은 문자를 표현하기 위해 캐릭터용으로 2진 코드(ASCII 또는 유니코드)를 사용하면 그것은 텍스트 파일이다. 만약, 파일 내 존재하는 2진 값들이 기계어 코드 또는 수치 데이터(같은 내부 표현을 사용하는 `long` 또는 `double`값) 또는 이미지나 음악 인코딩을 표현한다면 컨텐츠는 바이너리이다.

텍스트 파일을 처리하기 위한 일부 규칙을 가져오기 위해, C는 파일에 접근하는 두 가지 방식인 텍스트 모드와 바이너리 모드를 제공한다. 바이너리 모드에서, 프로그램은 파일의 각 바이트에 그리고 모든 바이트에 접근할 수 있다. 그러나 텍스트 모드에서는 프로그램이 인식하는 내용과 파일에 있는 내용이 다를 수 있다. 

텍스트 관점에서는, 그러한 것들의 지역(local) 환경의 표현이 한 파일을 읽을 때 라인끝이나 파일끝이 C 관점에서 맵핑되는 것이다. 이와 비슷하게 C 관점은 출력의 지역 표현으로 맵핑된다. 

# 입출력 수준

파일에 대한 접근을 처리하는 두 가지 수준 중 어느 하나를 선택할 수 있다. 저수준 입출력은 운영체제가 제공하는 기본적인 입출력 서비스를 사용한다. 표준 고수준 입출력은 C 라이브러리 함수들의 표준 패키지와 `stdio.h` 헤더 파일 정의들을 사용한다. 모든 운영체제가 동일한 저수준 입출력 모델로 표현될 수 있다는 보장이 없기 떄문에, C 표준은 표준 입출력 패키지만을 제공한다. 특별한 구현을 위해 저수준 라이브러리들도 제공하지만, C 표준은 휴대형 입출력 모델의 이식성을 보장한다.

## 표준 파일

C 프로그램은 사용자를 위해 표준 입력, 표준 출력, 표준 에러 출력이라는 세 개의 파일을 자동으로 연다. 표준 입력은 디폴트로 일반적으로 시스템이 사용하는 키보드와 같은 입력 장치다. 표준 출력과 표준 에러 출력은 둘 다 일반적으로 시스템이 사용하는 디스플레이다. 리디렉션을 사용하여 다른 파일들을 표준 입력이나 표준 출력으로 인식되게 만든다. 

## 표준 입출력
표준 입출력 패키지는 이식성 외에도, 저수준 입출력에 비해 두 가지 장점을 가지고 있다. 

1. 다양한 입출력 문제들을 간단하게 처리하는 전문화된 많은 함수들을 제공한다.
2. 입력과 출력에 버퍼를 사용한다. 정보가 한 번에 한 바이트씩 전달되지 않고, 큰 덩어리로 전달된다. 이와 같은 버퍼링은 데이터 전송 속도를 크게 증가시킨다.

아래 예제는 표준 입출력을 이용하여 파일을 읽고, 그 파일에 들어 있는 문자들의 개수를 카운트하는 방법이다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[]) {
    int ch;
    FILE *fp;
    unsigned long count = 0;

    if (argc != 2) {
        printf("사용법: %s filename\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    if((fp = fopen(argv[1], "r")) == NULL) {
        printf("%s 파일을 열 수 없음\n", argv[1]);
        exit(EXIT_FAILURE);
    }

    while ((ch = getc(fp)) != EOF) {
        putc(ch, stdout);
        count++;
    }
    fclose(fp);
    printf("%s 파일에는 %ld개의 문자가 존재한다\n", argv[1], count);

    return 0;
}
```

### 명령행 전달인자 검사하기

위 `count.c` 같은 유형의 파일은 `.\count filename`으로 실행 가능하다.

`argc`의 값으로 프로그램은 명령행 전달인자가 존재하는지 검사한다. 명령행 전달인자가 없으면, 프로그램은 사용법을 안내하는 메시지를 출력하고 종료한다. 문자연 `argv[0]`은 프로그램의 이름이다. 프로그램 이름을 명시적으로 지정하는 대신에 `argv[0]`을 사용하면, 실행 파일의 이름을 변경했을 떄 에러 메시지도 자동으로 변경된다. 또한 이 기능은 한 파일이 여러 개의 이름을 가질 수 있는 Unix와 같은 환경에서 매우 유용하다. 

`exit()` 함수는 열려 있는 모든 파일들을 닫으면서 프로그램을 종료시킨다. 일반적으로 프로그램이 정상적으로 종료되는 경우에는 0(`EXIT_SUCCESS`)을 전달하고, 비정상적으로 종료되는 경우에는 0이 아닌 값(`EXIT_FAILURE`)들을 전달한다. 

`main()`에 대한 최초의 호출에 `return`을 사용하는 것은, `exit()`을 호출하는 것과 동일한 효과를 가져온다. 따라서, `main()`에 있는 다음과 같은 문장은

```c
return 0;
```

다음과 같은 문장과 동일한 효과를 가져온다.

```c
exit(0);
```

"최초 호출"이라는 문구는, `main()`을 재귀적인 프로그램으로 만들었을 떄, 여전히 `exit()`은 프로그램을 종료한다. 그러나 `return`은 최초 수준에 도달할 떄까지 바로 이전의 재귀 수준으로 제어를 넘긴다. 마침내 최초의 수준에 도달했을 떄, `return`은 프로그램을 종료한다. 또한 `exit()`은 `main()`이 아닌 다른 함수에서 호출되더라도 프로그램을 종료한다는 것이다.

### fopen()
위 예제는 `fopen()`을 사용하여 파일을 연다. 이 함수는 `stdio.h`에 선언되어 있다. 첫 번쨰 전달인자는 열려고 하는 파일의 이름이다. 정확하게는 그 파일 이름을 가지고 있는 문자열의 주소이다. 두 번째 전달인자는 파일을 여는 데 사용할 모드를 지정하는 문자열이다. 

|모드 문자열|의미|
|:---:|:---:|
"r"|읽기 위해 파일을 텍스트 모드로 접근
"w"|쓰기 위해 파일을 텍스트 모드로 접근한다. 파일이 이미 존재하면 파일 길이를 0으로 만든다. 파일이 없으면 새 파일을 만든다.
"a"|쓰기 위해 파일을 텍스트 모드로 연다. 파일이 이미 존재하면 그 파일의 끝에 덧붙인다. 파일이 없으면 새 파일을 만든다.
"r+"|갱신하기 위해(읽고 쓰기 위해) 파일을 텍스트 모드로 연다.
"w+"|갱신하기 위해(읽고 쓰기 위해) 파일을 텍스트 모드로 연다. 파일이 이미 존재하면 파일 길이를 0으로 만든다. 파일이 없으면 새 파일을 만든다.
"a+"|갱신하기 위해(읽고 쓰기 위해) 파일을 텍스트 모드로 연다. 파일이 이미 존재하면 그 파일의 끝에 덧붙인다. 파일이 없으면 새 파일을 만든다. 읽기는 전체를 읽고 쓰기는 끝에 덧붙일 수만 있다.
"rb", "wb", "ab", "ab+", "a+B", "wb+", "w+b", "rb+", "r+b"|텍스트 모드가 아닌 바이너리 모드로 동작한다는 것을 제외하고, 앞의 모드들과 같다.
"wx", "wbx", "w+x", "wb+x" 또는 "w+bx"|(C11) 파일이 이미 존재하고 exclusive 모드에서 파일을 오픈하여 fail한다는 것을 제외하면 non-x 모드와 같다.

x가 있는 쓰기 모드는 기존의 쓰기 모드와 비교해 많은 기능을 제공한다. 먼저, 전통적인 쓰기 모드 중 하나에 존재하는 파일을 오픈하려하면, `fopen()`이 파일을 제로길이, 잃어버린 파일 컨텐츠로 절사한다. 그러나 x가 있는 모드는 파일을 무사히 떠나는 대신, 실패(fail)의 원인이 된다. 또한, 환경의 확장이 허락할 때까지 x 모드의 독점 기능은 현재의 프로세스가 파일을 닫을 떄까지 다른 프로그램이나 스레드가 파일에 접근하지 못하게 한다.

프로그램이 성공적으로 파일을 열면, `fopen()`은 파일 포인터를 리턴한다. `FILE`은 `stdio.h`에 정의되어 있는 유도 데이터형이다. 포인터 `fp`는 실제 파일을 가리키지 않는다. 대신에 그 파일의 입출력에 사용되는 버퍼 정보를 포함하여, 그 파일에 관한 정보가 들어 있는 데이터 객체를 가리킨다. 표준 라이브러리에 있는 입출력 함수들은 버퍼를 사용하기 떄문에, 버퍼가 어디에 있는지 알 필요가 있다. 또한 버퍼가 얼마나 채워져 있는지, 어느 파일을 사용하는지도 알 필요가 있다. 이 정보들은, 필요할 때 함수들이 버퍼를 다시 채우거나 비우는 것을 가능하게 한다. `fp`가 가리키는 데이터 객체가 그 모든 정보를 가지고 있다. 

`fopen()` 함수는 그 파일을 열 수 없을 때(디스크가 가득 차 있을 떄, 파일이 찾는 디렉토리에 없을 떄, 이름이 틀릴 떄, 접근 제한, 하드웨어 문제) 널 포인터를 리턴한다. 이 프로그램은 `fp`가 `NULL`이면 종료된다. 

### getc()와 putc()
`getchar()`, `putchar()` 함수와 아주 비슷하게 동작하는 함수다. 차이점은 어느 파일을 사용할 것인지 알려줘야 한다는 것이다. 따라서

```c
ch = getc(fp);
```

위 코드는 `fp`가 나타내는 파일로부터 하나의 문자를 얻는다. 

```c
putc(ch, fpout);
```

위 코드는 문자 `ch`를 `FILE` 포인터 `fpout`이 나타내는 파일에 출력한다. 

**EOF**
```
파일로부터 데이터를 읽는 프로그램은, 파일의 끝에 도달했을 때 읽기를 멈출 필요가 있다. `getc()` 함수는, 하나의 문자를 읽으려 시도하다가 파일의 끝에 도달했다는 것을 발견하면, `EOF`라는 특별한 값을 리턴한다. 
```

### fclose()
필요할 때 버퍼를 비우면서 `fp`가 가리키는 파일을 닫는다. 파일을 성공적으로 닫으면 0을 리턴하고, 그렇지 않으면 `EOF`를 리턴한다. `fclose()` 함수는, 디스크가 가득 차 있을 때, 플로피 디스크가 제거되었을 떄, 또는 다른 입출력 에러가 발생했을 떄 파일을 닫는데 실패할 수 있다.

**표준 파일을 가리키는 포인터에 관한 표**

|표준 파일|파일 포인터|일반적으로
|:---:|:---:|:---:|
표준 입력|stdin|키보드
표준 출력|stdout|스크린
표준 에러|stderr|스크린

## 간단한 파일 압축 프로그램

```c
// 파일을 2/3으로 압축한다
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define LEN 30

int main(int argc, char *argv[]) {
    FILE *in, *out;
    int ch;
    char name[LEN];
    int count = 0;

    if (argc < 2) {
        fprintf(stderr, "사용법: %s filename\n", argv[0]);
        exit(EXIT_FAILURE);
    }
    if((in = fopen(argv[1], "r")) == NULL) {
        fprintf(stderr, "\"%s\" 파일을 열 수 없음\n", argv[1]);
        exit(EXIT_FAILURE);
    }

    strncpy(name, argv[1], LEN - 5);
    name[LEN - 5] = '\0';
    strcat(name, ".red");

    if((out = fopen(name, "w")) == NULL) {
        fprintf(stderr, "출력 파일을 만들 수 없음\n");
        exit(3);
    }

    while((ch = getc(in)) != EOF) {
        if(count++ % 3 == 0) {
            putc(ch, out);
        }
    }

    if(fclose(in) != 0 || fclose(out) != 0) {
        fprintf(stderr, "파일을 닫는데 에러 발생\n");
    }

    return 0;
}
```

`fprintf()`는 첫 번쨰 전달인자로 파일 포인터를 사용한다는 것을 제외하고 `printf()`와 같다. 에러 메시지들을 표준 에러 출력으로 보내기 위해 파일 포인터 `stderr`을 사용했다. 이것이 C의 표준 관례이다.

출력 파일을 위한 새 이름을 만들기 위해, 프로그램은 `strncpy()`를 사용하여 파일 이름을 배열 `name`에 복사한다. `LEN - 5` 전달인자는 확장자 `.red`와 종결 `NULL` 문자를 위한 공간을 남겨둔다. `argv[1]`이 `LEN - 5`보다 크면, 널 문자는 복사되지 않는다. 그래서 프로그램은 만일의 경우를 생각하여 널 문자를 추가한다. 

`strncpy()` 함수를 호출한 후, `name`에 있는 첫 번째 널 문자는 `strcat()` 함수가 그 문자열에 적용되었을 때 `.red`에 있는 마침표에 의해 덮어 쓰여진다. 이 예제에서는 결과적으로 새로운 이름 `filename.red`이 생성된다. 

# 파일 입출력 함수

## fprintf() & fscanf()

파일을 나타내는 첫 번째 전달인자를 요구한다.

```c
fscanf(stdin, "%s", words);

fprintf(stdout, words);
```

표준 입출력을 이용하여 `words` 문자열을 대입하고 출력한다.

## fgets() & fputs()

`fgets()`는 세 개의 전달인자를 사용한다. 첫 번째는 입력을 저장할 주소, 두 번째는 입력 문자열의 최대 크기를 나타내는 정수, 세 번째는 읽을 파일을 가리키는 파일 포인터이다. `char`형 배열 `arr`과 파일 포인터 `fp`가 존재한다고 가정하면 다음과 같이 선언한다.

```c
fgets(arr, 10, fp);
```

`fgets`는 상한보다 하나 적은 수(위 코드에서는 9개)의 문자들을 읽을 떄까지 또는 파일 끝을 만날 때까지 문자들을 읽되, 첫 개행 문자까지 읽는다. 그리고 `fgets()`는 읽은 것이 문자열이 되도록 종결 `NULL` 문자를 추가한다. `fgets()` 전체 라인을 읽는다면, `NULL` 문자 바로 앞에 라인의 끝을 표시하는 개행 문자를 추가한다.`fgets()`는 `EOF`를 만나면 `NULL`값을 반환한다. 이 값을 이용하여 파일의 끝에 도달했는지 검사할 수 있다.

`fputs()`는 두 개의 전달인자를 사용한다. 첫 번쨰는 문자열의 주소, 두 번쨰는 파일 포인터이다. 

```c
fputs(arr, fp);
```

`fputs()`는 개행 문자를 덧붙이지 않기에 `fgets()`와 같이 사용된다.

## fseek() & ftell()

`fseek()`는 세 개의 전달인자를 사용한다. 첫 번쨰는 파일 포인터, 두 번째는 오프셋(offset)이라는 전달인자를 사용한다. 이것은 시작 위치로부터 얼마나 멀리 가야 하는지 알려준다. 이 전달인자는 `long`형 값이다. 이 값은 양수(앞으로), 음수(뒤로), 0이 될 수 있다.

세 번쨰는 모드로, 시작 위치를 나타낸다. `stdio.h`파일에 정의되어 있다.

모드|시작위치
:---:|:---:
SEEK_SET|파일의 시작
SEEK_CUR|현재 위치
SEEK_END|파일의 끝

```c
fseek(fp, 0L, SEEK_SET);  //파일의 시작 위치로 이동
fseek(fp, 2L, SEEK_CUR);  //파일의 현재 위치에서 2바이트 앞으로 이동
fssek(fp, 0L, SEEK_END);  //파일의 끝으로 이동
```

위 코드가 성공적으로 실행되면 `fseek()`는 0을 리턴한다. 에러가 발생하면 -1을 리턴한다.

`ftell()`은 `long`형이다. 이 함수는 현재의 파일 위치를 리턴한다. `stdio.h`에 선언되어 있는 이 함수는 파일의 시작으로부터 첫 바이트를 0으로 하는 바이트 수를 리턴함으로써 파일 위치를 지정한다. 이 정의는 바이너리 모드로 열린 파일들에 적용된다. 따라서 텍스트 모드와 바이너리 모드에서 다르게 동작할 수 있다. 

```c
ftell(fp);
```

## fgetpos() & fsetpos()

`fseek()`와 `ftell()`에 관련된 한 가지 잠재적 문제는, 이 함수들이 파일 크기를 `long`형으로 나타낼 수 있는 값으로 제한한다는 것이다. 따라서 `long`형 값으로 위치를 지정하는 대신, 그 목적을 위해 설계된 `fpos_t`라는 새로운 데이터형을 사용한다. 이 데이터형은 배열의 형태는 될 수 없지만, 그 외에 다른 특성은 지정되지 않았다.

`fgetpos()`는 다음과 같은 프로토타입을 가진다.

```c
int fgetpos(FILE * restrict stream, fpos_t * restrict pos);
```

호출되면 이 함수는 `fpos_t` 값을 `pos`가 가리키는 위치에 넣는다. 그 값은 파일 내 어떤 위치를 나타낸다. 성공하면 0을, 실패하면 0이 아닌 값을 리턴한다.

`fsetpos()`는 다음과 같은 프로토타입을 가진다.

```c
int fsetpos(FILE *stream, const fpos_t *pos);
```
이 함수는 `pos`가 가리키는 위치에 있는 `fpos_t`값을 사용하여 파일 포인터를 그 값이 나타내는 위치로 설정한다. 성공하면 0, 실패하면 0이 아닌 값을 리턴한다. `fpos_t`값은 `fgetpos()` 호출에서 얻은 값이어야 한다.

# 그 밖에 표준 입출력 함수

## nugetc()

C가 나타내는 문자를 입력 스트림에 다시 반납한다. 사용자가 하나의 문자를 입력 스트림에 반납하면, 표준 입력 함수의 다음 번 호출은 그 문자를 읽는다.

```c
ungetc(ch, stdin);
```

![image](/assets/images/c_image_03.png)

## fflust()
출력 버퍼에 아직 남아 있는 데이터를 `fp`가 가리키는 출력 파일로 보낸다. 이 과정을 버퍼 지우기라고 한다. `fp`가 `NULL` 포인터라면 모든 출력 버퍼들을 비운다

## setvbuf()

표준 입출력 함수들이 사용할 또 하나의 버퍼를 설정한다. 이 함수는, 파일을 열고 난 후 그 스트림에 어떤 다론 조작이 가해지기 전에 호출된다. 프로토타입은 다음과 같다.

```c
int setvbuf(FILE * restrict fp, char * restrict buf, int mode, size_t size);
```

`mode`는 `_IOFBF`(완전 버퍼링), `_IOLBF`(라인 버퍼링), `_IONBF`(비버퍼링) 중 하나를 택한다. 성공시 0을 리턴, 실패 시 0이 아닌 값을 리턴한다.

## fread() & fwrite()
바이너리 입출력을 담당하는 함수이다. `fprintf()`로 숫자를 입력하여도 그것은 최종적으로 문자열로 저장된다. 이런 과정에서 값이 변할 수도 있다. 따라서 프로그램이 사용하는 비트 패턴과 동일한 비트 패턴을 사용하는 것이 가장 정확하고 일관되게 수를 저장하는 방법이다. 이렇게 프로그램에서 사용하는 표현과 동일한 표현으로 데이터를 저장할 떄, 그 데이터가 바이너리 형태로 저장된다고 말한다. 수치가 문자 시퀀스로 변환되는 일이 일어나지 않는다. 표준 입출력의 경우, `fread()`와 `fwrite()`가 이와 같은 바이너리 서비스를 제공한다.

실제로는 문자 코드 또한 바이너리 표현을 사용한다. 다만 파일에 있는 모든 데이터가 문자 코드로 해석된다면, 그 파일이 텍스트 데이터를 가지고 있다고 하는 것이다. 데이터의 일부 또는 전체가 바이너리 형태의 수치 데이터로 해석되면, 그 파일이 바이너리 데이터를 가지고 있다고 말한다.

### size_t fwrite()

`fwrite()`는 다음과 같은 프로토타입을 가진다.

```c
size_t fwrite(const void * restrict ptr, size_t size, size_t nmumb, FILE * restrict fp);
```
이 함수는 바이너리 데이터를 파일에 저장한다. `size`는 저장할 그 데이터 덩어리들의 바이트 단위를 나타낸다. `nmemb`는 저장할 데이터 덩어리들의 수를 나타낸다. `fp`는 일반적으로 그 데이터가 저장될 파일을 나타낸다. 크기가 256 바이트인 하나의 데이터 객체를 저장하려는 코드는 다음과 같다.

```c
char buffer[256];
fwrite(buffer, 256, 1, fp);
```
위 코드는 256 바이트인 데이터 덩어리 하나를 `buffer`로부터 파일로 저장한다. 

```c
double arr[10];
fwrite(arr, sizeof (double), 10, fp);
```

이런 호출은 10개의 데이터 덩어리를 `arr` 배열로부터 파일로 저장한다. 

`fwrite`는 성공적으로 저장한 항목의 수(일반적으로 `nmemb`와 같음)를 리턴한다. 기록 에러가 발생하면 더 작은 값을 리턴할 것이다.

### size_t fread()
`fread()`는 다음과 같은 프로토타입을 가진다.

```c
size_t fread(void * restrict ptr, size_t size, size_t nmemb, FILE * restrict fp);
```

`ptr`이 파일로부터 읽은 데이터를 저장할 메모리 공간의 주소이다. 

```c
double arr[10];
fread(arr, sizeof (double), 10, fp);
```

이 호출은 `double`형 크기의 10개 값을 읽어 `arr`에 복사한다. `fread()`또한 성공적으로 읽은 항목의 수를 리턴한다. 읽기 에러 또는 `EOF`에 도달한 경우에는 더 작을 수 있다.

## feof() & ferror()
```c
int feof(FILE *fp);
int ferror(FILE *fp);
```

표준 입력 함수들이 `EOF`를 리턴할 떄 일반적으로 이것은 파일의 끝에 도달했다는 것이다. 그러나 읽기 에러가 발생했다는 것일 수도 있다. `feof()`와 `ferror()`를 사용하면 이 두 가지 가능성을 구별할 수 있다. 

`feof()`는 마지막 입력 호출에서 파일의 끝을 만나면 0이 아닌 값을 리턴한다. 그렇지 않으면 0을 리턴한다.

`ferror()`는 읽기 에러나 쓰기 에러가 발생하면 0이 아닌 값을 리턴한다. 그렇지 않으면 0을 리턴한다.

